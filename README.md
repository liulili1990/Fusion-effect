# Fusion-effect
This is the R code used in the paper "Capturing Heterogeneity in Repeated Measures Data by Fusion Penalty".
rm(list=ls())
library(MASS)
library(ggplot2)
library(lme4)
library(nlme)
library(mclust)#adjustRI
Sn=function(x,t){
xx=1-t/sqrt(sum(x^2))
if(xx>0){
s=xx*x
}else{
s=0*x
}
list(s=s)
}

Theta_MCP=function(u,lambda){
L=length(u)
Ta=rep(0,L)
for(k in 1:L){
uabs=abs(u[k])
if(uabs<=(v*lambda)){
Ta[k]=Sn(x=u[k],t=lambda/eta)$s/(1-1/(v*eta))
}else{
Ta[k]=u[k]
}
}
list(Ta=Ta)
}

Theta_SCAD=function(u,lambda){
L=length(u)
Ta=rep(0,L)
for(k in 1:L){
uabs=abs(u[k])
if(uabs<=(lambda+lambda/eta)){
Ta[k]=Sn(x=u[k],t=lambda/eta)$s
}else if(uabs>(lambda+lambda/eta)&uabs<=(v*lambda)){
Ta[k]=Sn(x=u[k],t=v*lambda/((v-1)*eta))$s/(1-1/((v-1)*eta))
}else{
Ta[k]=u[k]
}
}
list(Ta=Ta)
}
eta=1
v=3
Fn_SCAD=function(lambda){
r=rep(0,(m-1)*m/2)
theta=theta0
upsilon=upsilon0
counter=1
repeat{
ahat=solve(t(Z)%*%Qx%*%Z+eta*t(Delta)%*%Delta)%*%(t(Z)%*%Qx%*%Y+eta*t(Delta)%*%(theta-1/eta*upsilon))
#ahat=as.vector(ahat)
betahat=solve(t(X)%*%X)%*%t(X)%*%(Y-Z%*%ahat)
for(i in 1:(m-1)){
Pi=ahat[i]-ahat[(1:m)>i]+1/eta*upsilon[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]
theta[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]=Theta_SCAD(Pi,lambda)$Ta
upsilon[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]=upsilon[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]+eta*(ahat[i]-ahat[(1:m)>i]-theta[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)])
r[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]=ahat[i]-ahat[(1:m)>i]-theta[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]
}
rnorm=sqrt(sum(r^2))
if(rnorm<0.00001){
break
}
if(counter>1000){
break
}
counter=counter+1
#print(counter)
}
list(ahat=ahat,betahat=betahat)
}

Fn_MCP=function(lambda){
r=rep(0,(m-1)*m/2)
theta=theta0
upsilon=upsilon0
counter=1
repeat{
ahat=solve(t(Z)%*%Qx%*%Z+eta*t(Delta)%*%Delta)%*%(t(Z)%*%Qx%*%Y+eta*t(Delta)%*%(theta-1/eta*upsilon))
betahat=solve(t(X)%*%X)%*%t(X)%*%(Y-Z%*%ahat)
for(i in 1:(m-1)){
Pi=ahat[i]-ahat[(1:m)>i]+1/eta*upsilon[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]
theta[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]=Theta_MCP(Pi,lambda)$Ta
upsilon[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]=upsilon[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]+eta*(ahat[i]-ahat[(1:m)>i]-theta[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)])
r[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]=ahat[i]-ahat[(1:m)>i]-theta[((i-1)*(2*m-i)/2+1):((i-1)*(2*m-i)/2+m-i)]
}
rnorm=sqrt(sum(r^2))
#print(rnorm)
if(rnorm<0.00001){
break
}
if(counter>1000){
break
}
counter=counter+1
#print(counter)
}
list(ahat=ahat,betahat=betahat)
}

randindex=function(x,y){
agree=NULL
x=as.vector(x)
y=as.vector(y)
for(i in 1:(m-1)){
  for(j in (i+1):m){
  xstatus=ifelse(x[i]==x[j],1,0)
  ystatus=ifelse(y[i]==y[j],1,0)
  agree=c(agree,ifelse(xstatus==ystatus,1,0))
  }
}
RI=sum(agree)/(m*(m-1)/2)
return(RI)
}
boot.cluster=function(x,id){
  boot.id=sample(unique(id),replace=T)
  out=lapply(1:length(boot.id), function(newid){cbind(x[which(id==boot.id[newid]),],newid)})
  return(do.call("rbind",out))
}

nrep=50
T=1
filedir="/scratch/lili1990/data1-200/data"
m=200
p=1
rho=0.5
eta=1
v=3
ngroup=rep(0,nrep)
aest=matrix(0,m,nrep)
betaest=rep(0,nrep)
aMSE=rep(0,nrep)
se.beta=rep(0,nrep)
cp.beta=rep(0,nrep)
RI=rep(0,nrep)
ARI=rep(0,nrep)
se.a=matrix(0,nrep,3)
cp.a=NULL
Aest=NULL
ngroup_mcp=rep(0,nrep)
aest_mcp=matrix(0,m,nrep)
betaest_mcp=rep(0,nrep)
aMSE_mcp=rep(0,nrep)
se.beta_mcp=rep(0,nrep)
cp.beta_mcp=rep(0,nrep)
RI_mcp=rep(0,nrep)
ARI_mcp=rep(0,nrep)
se.a_mcp=matrix(0,nrep,3)
cp.a_mcp=NULL
Aest_mcp=NULL
afix=matrix(0,m,nrep)
betafix=rep(0,nrep)
aMSE_fix=rep(0,nrep)
se.beta_fix=rep(0,nrep)
cp.beta_fix=rep(0,nrep)
aran=matrix(0,m,nrep)
betaran=rep(0,nrep)
aMSE_ran=rep(0,nrep)
se.beta_ran=rep(0,nrep)
cp.beta_ran=rep(0,nrep)
aor=matrix(0,m,nrep)
betaor=rep(0,nrep)
aMSE_or=rep(0,nrep)
se.beta_or=rep(0,nrep)
cp.beta_or=rep(0,nrep)
se.a_or=matrix(0,nrep,3)
cp.a_or=NULL
Aor=matrix(0,nrep,3)
ATRUE=matrix(0,m,nrep)
Im=diag(m)
Delta=NULL
for(i in 1:(m-1)){
Delta=cbind(Delta,(Im[,i]-Im[,(1:m)>i]))
}
Delta=t(Delta)
xi=seq(0.14,0.35,length=10)
nxi=length(xi)
for(irep in 1:nrep){
ni=sample(c(1,2),m,replace=TRUE,prob=c(1/2,1/2))
lni=length(ni)
N=sum(ni)
ATRUE[,irep]=atrue=sample(c(-1.5,0,1.5),m,replace=TRUE,prob=c(1/3,1/3,1/3))
X=rnorm(N,0,1)
Z=matrix(0,N,m)
for(k in 1:m){
if(k==1){
Z[(1:ni[1]),1]=rep(1,ni[1])
}else{
Z[(sum(ni[(1:m)<k])+1):(sum(ni[(1:m)<k])+ni[k]),k]=rep(1,ni[k])
}
}
ZZ=Z
beta=2
eps=rnorm(N,0,0.4)
Atrue=c(-1.5,0,1.5)
Y=as.vector(Z%*%atrue)+as.vector(X*beta)+eps
id=NULL
a=NULL
for(k in 1:m){
id=c(id,rep(k,ni[k]))
a=c(a,rep(atrue[k],ni[k]))
}
Data=as.data.frame(cbind(id,X,Y,a))
write_data=as.data.frame(cbind(id,X,Y,a))
filename=paste(filedir,(T-1)*nrep+irep,".csv",sep="")
write.matrix(write_data,filename,sep=",")
X=Data$X
Y=Data$Y
Z=ZZ

#fixed effect
ZX=cbind(Z,X)
para=solve(t(ZX)%*%ZX)%*%t(ZX)%*%Y
afix[,irep]=para[1:m]
betafix[irep]=para[(m+1):(m+p)]
aMSE_fix[irep]=sqrt(sum((atrue-afix[,irep])^2))/sqrt(m)
sighat_fix=sum((Y-Z%*%afix[,irep]-X*betafix[irep])^2)/(N-m-p)
se.beta_fix[irep]=sqrt(sighat_fix*solve(t(X)%*%X-(t(X)%*%Z)%*%solve(t(Z)%*%Z)%*%(t(Z)%*%X)))
cp.beta_fix[irep]=ifelse(abs(betafix[irep]-beta)<1.96*se.beta_fix[irep],1,0)

#random effect
li=c(1:m)
all=Z%*%li
data_ran=data.frame(Y=Y,all=all,X=X)
model=lme(Y~X,random=~1|all,data=data_ran)
#model2=lmer(Y~X+(1|all),data=Data)
print(summary(model))
betaran[irep]=model$coef$fixed[2]
aran[,irep]=model$coef$random$all+model$coef$fixed[1]
aMSE_ran[irep]=sqrt(sum((atrue-aran[,irep])^2))/sqrt(m)
sig1=model$sigma
se.beta_ran[irep]=summary(model)$tTable[2,2]
cp.beta_ran[irep]=ifelse(abs(betaran[irep]-beta)<1.96*se.beta_ran[irep],1,0)

#ORACLE
g1=which(atrue==-1.5)
g2=which(atrue==0)
g3=which(atrue==1.5)
L1=length(g1)
L2=length(g2)
L3=length(g3)
Zor=matrix(0,N,3)
Q1=sum(ni[g1])
Q2=sum(ni[g2])
Q3=sum(ni[g3])
Zor[(1:Q1),1]=rep(1,Q1)
Zor[(Q1+1):(Q1+Q2),2]=rep(1,Q2)
Zor[(Q1+Q2+1):(Q1+Q2+Q3),3]=rep(1,Q3)
Xor1=NULL
Yor1=NULL
for(k in 1:L1){
Xn1=X[(sum(ni[(1:m)<g1[k]])+1):(sum(ni[(1:m)<g1[k]])+ni[g1[k]])]
Xor1=c(Xor1,Xn1)
Yn1=Y[(sum(ni[(1:m)<g1[k]])+1):(sum(ni[(1:m)<g1[k]])+ni[g1[k]])]
Yor1=c(Yor1,Yn1)
}
Xor2=NULL
Yor2=NULL
for(k in 1:L2){
Xn2=X[(sum(ni[(1:m)<g2[k]])+1):(sum(ni[(1:m)<g2[k]])+ni[g2[k]])]
Xor2=c(Xor2,Xn2)
Yn2=Y[(sum(ni[(1:m)<g2[k]])+1):(sum(ni[(1:m)<g2[k]])+ni[g2[k]])]
Yor2=c(Yor2,Yn2)
}
Xor3=NULL
Yor3=NULL
for(k in 1:L3){
Xn3=X[(sum(ni[(1:m)<g3[k]])+1):(sum(ni[(1:m)<g3[k]])+ni[g3[k]])]
Xor3=c(Xor3,Xn3)
Yn3=Y[(sum(ni[(1:m)<g3[k]])+1):(sum(ni[(1:m)<g3[k]])+ni[g3[k]])]
Yor3=c(Yor3,Yn3)
}
Xor=c(Xor1,Xor2,Xor3)
Yor=c(Yor1,Yor2,Yor3)
ZXor=cbind(Zor,Xor)
para_or=as.vector(solve(t(ZXor)%*%ZXor)%*%t(ZXor)%*%Yor)
aor[g1,irep]=para_or[1]
aor[g2,irep]=para_or[2]
aor[g3,irep]=para_or[3]
betaor[irep]=para_or[4]
aMSE_or[irep]=sqrt(sum((atrue-aor[,irep])^2))/sqrt(m)
Aor[irep,]=para_or[1:3]

#SCAD
xx=solve(t(X)%*%X)
Qx=diag(N)-X%*%xx%*%t(X)
a0=model$coef$random$all+model$coef$fixed[1]
up0=rep(0,m)
theta0=NULL
upsilon0=NULL
for(i in 1:(m-1)){
theta0=c(theta0,(a0[i]-a0[(1:m)>i]))
upsilon0=c(upsilon0,(up0[i]-up0[(1:m)>i]))
}
Group=rep(0,nxi)
bic=rep(0,nxi)
b1=rep(0,nxi)
b2=rep(0,nxi)
ascad=list()
betascad=list()
for(i in 1:nxi){
value=Fn_SCAD(lambda=xi[i])
ascad[[i]]=value$ahat
betascad[[i]]=value$betahat
z1=round(ascad[[i]],3)
ta1=as.data.frame(table(z1))
print(ta1)
Group[i]=dim(ta1)[1]
print(Group)
R=Y-Z%*%ascad[[i]]-X%*%betascad[[i]]
b1[i]=log(sum(R^2)/N)
Cn=5*log(log(N+p))
b2[i]=log(N)/N*(Group[i]+p)
bic[i]=b1[i]+Cn*b2[i]
}
plot(xi,bic)
I=which.min(bic)
aest[,irep]=ascad[[I]]
betaest[irep]=betascad[[I]]
z=round(ascad[[I]],3)
ta=as.data.frame(table(z))
ngroup[irep]=dim(ta)[1]
print(ngroup)
aMSE[irep]=sqrt(sum((atrue-aest[,irep])^2))/sqrt(m)
RI[irep]=randindex(z,atrue)
ARI[irep]=adjustedRandIndex(z,atrue)
if(ngroup[irep]==3){
Aest=rbind(Aest,as.numeric(as.matrix(ta[,1])))
}else{
Aest=rbind(Aest,rep(0,3))
}


#MCP
Group_mcp=rep(0,nxi)
bic_mcp=rep(0,nxi)
b3=rep(0,nxi)
b4=rep(0,nxi)
amcp=list()
betamcp=list()
for(i in 1:nxi){
value_mcp=Fn_MCP(lambda=xi[i])
amcp[[i]]=value_mcp$ahat
betamcp[[i]]=value_mcp$betahat
z2=round(amcp[[i]],3)
ta2=as.data.frame(table(z2))
print(ta2)
Group_mcp[i]=dim(ta2)[1]
print(Group_mcp)
R_mcp=Y-Z%*%amcp[[i]]-X%*%betamcp[[i]]
b3[i]=log(sum(colSums(R_mcp^2))/N)
Cn=5*log(log(N+p))
b4[i]=log(N)/N*(Group_mcp[i]+p)
bic_mcp[i]=b3[i]+Cn*b4[i]
}
plot(xi,bic_mcp)
I1=which.min(bic_mcp)
aest_mcp[,irep]=amcp[[I1]]
betaest_mcp[irep]=betamcp[[I1]]
z_mcp=round(amcp[[I1]],3)
ta_mcp=as.data.frame(table(z_mcp))
ngroup_mcp[irep]=dim(ta_mcp)[1]	
print(ngroup_mcp)
aMSE_mcp[irep]=sqrt(sum((atrue-aest_mcp[,irep])^2))/sqrt(m)
RI_mcp[irep]=randindex(z_mcp,atrue)
ARI_mcp[irep]=adjustedRandIndex(z_mcp,atrue)
if(ngroup_mcp[irep]==3){
Aest_mcp=rbind(Aest_mcp,as.numeric(as.matrix(ta_mcp[,1])))
}else{
Aest_mcp=rbind(Aest_mcp,rep(0,3))
}
file1=paste("/scratch/lili1990/data1-200/beta",-T,".txt",sep="")
result1=cbind(ngroup,betaest,aMSE,RI,ARI,ngroup_mcp,betaest_mcp,aMSE_mcp,RI_mcp,ARI_mcp,betaor,aMSE_or,betafix,se.beta_fix,cp.beta_fix,aMSE_fix,betaran,se.beta_ran,cp.beta_ran,aMSE_ran)
write.matrix(result1,file1,sep="\t")
file2=paste("/scratch/lili1990/data1-200/Aest",-T,".txt",sep="")
write.matrix(as.data.frame(Aest,col.names=NULL),file2,sep="\t")
file3=paste("/scratch/lili1990/data1-200/Aest_mcp",-T,".txt",sep="")
write.matrix(as.data.frame(Aest_mcp,col.names=NULL),file3,sep="\t")
file4=paste("/scratch/lili1990/data1-200/Aor",-T,".txt",sep="")
write.matrix(as.data.frame(Aor,col.names=NULL),file4,sep="\t")
file5=paste("/scratch/lili1990/data1-200/ahat",-T,".txt",sep="")
write.matrix(as.data.frame(aest,col.names=NULL),file5,sep="\t")
file6=paste("/scratch/lili1990/data1-200/ahat_mcp",-T,".txt",sep="")
write.matrix(as.data.frame(aest_mcp,col.names=NULL),file6,sep="\t")
file7=paste("/scratch/lili1990/data1-200/atrue",-T,".txt",sep="")
write.matrix(as.data.frame(ATRUE,col.names=NULL),file7,sep="\t")
}



